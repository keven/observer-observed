<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>The Question Field — Observer is the Observed</title>
  <meta name="description" content="An interactive art piece exploring how observation creates reality. Based on Krishnamurti-Bohm dialogues.">
  <meta property="og:title" content="The Question Field">
  <meta property="og:description" content="What do you see? Type and watch reality form from your words.">
  <meta property="og:type" content="website">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body {
      font-family: 'Cormorant Garamond', Georgia, serif;
      background-color: #0a0a0f;
      color: rgba(255, 255, 255, 0.9);
    }
    canvas { display: block; position: fixed; top: 0; left: 0; }

    /* Intro Screen */
    #intro {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(ellipse at center, #0a0a12 0%, #030305 100%);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 200; cursor: pointer;
      transition: opacity 1.5s ease, visibility 1.5s ease;
    }
    #intro.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    #intro h1 {
      font-size: clamp(2rem, 6vw, 4rem); font-weight: 300;
      letter-spacing: 0.15em; margin-bottom: 20px;
      opacity: 0; animation: fadeIn 2s ease 0.5s forwards;
    }
    #intro p {
      font-size: clamp(1rem, 2.5vw, 1.3rem); font-weight: 300;
      letter-spacing: 0.1em; opacity: 0; color: rgba(255,255,255,0.5);
      animation: fadeIn 2s ease 1.5s forwards;
    }
    #intro .enter-hint {
      position: absolute; bottom: 60px; font-size: 0.9rem;
      letter-spacing: 0.2em; text-transform: uppercase; opacity: 0;
      animation: fadeIn 2s ease 2.5s forwards, pulse 3s ease-in-out 3s infinite;
    }
    @keyframes fadeIn { to { opacity: 1; } }
    @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.8; } }

    /* Main Interface */
    #interface {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
      z-index: 10; padding: 20px; padding-bottom: 12vh;
      opacity: 0; transition: opacity 1s ease;
    }
    #interface.visible { opacity: 1; }
    #question {
      font-size: clamp(1.5rem, 4vw, 2.8rem); color: rgba(255,255,255,0.75);
      margin-bottom: 50px; letter-spacing: 0.12em; font-weight: 300; text-align: center;
      transition: opacity 1.5s ease, transform 1.5s ease;
      text-shadow: 0 0 30px rgba(0,0,0,0.8);
    }
    #question.faded { opacity: 0.2; transform: translateY(-30px) scale(0.95); }
    #input-container { position: relative; width: 100%; max-width: 650px; }
    #user-input {
      width: 100%; padding: 22px 35px;
      font-size: clamp(1.2rem, 3vw, 1.9rem);
      font-family: 'Cormorant Garamond', Georgia, serif; font-weight: 400;
      background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.15);
      border-radius: 6px; color: rgba(255,255,255,0.9); text-align: center;
      outline: none; transition: all 0.6s ease; letter-spacing: 0.06em;
      backdrop-filter: blur(10px);
    }
    #user-input::placeholder { color: rgba(255,255,255,0.3); font-style: italic; font-weight: 300; }
    #user-input:focus {
      background: rgba(0,0,0,0.4); border-color: rgba(255,255,255,0.25);
      box-shadow: 0 0 40px rgba(255,255,255,0.05);
    }

    /* Word Echo */
    #word-echo {
      position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
      font-size: 0.95rem; color: rgba(255,255,255,0.35);
      letter-spacing: 0.35em; text-transform: uppercase; font-weight: 300;
      opacity: 0; transition: opacity 0.8s ease;
    }
    #word-echo.visible { opacity: 1; }

    /* Stats */
    #stats {
      position: fixed; top: 20px; right: 20px;
      font-size: 11px; color: rgba(255,255,255,0.3);
      letter-spacing: 1px; text-align: right; z-index: 15;
    }

    /* Palette indicator */
    #palette-indicator {
      position: fixed; top: 20px; left: 20px;
      display: flex; gap: 5px; z-index: 15;
    }
    .color-dot { width: 10px; height: 10px; border-radius: 50%; opacity: 0.7; }

    /* Mode indicator */
    #mode-indicator {
      position: fixed; top: 45px; left: 20px;
      font-size: 11px; color: rgba(255,255,255,0.3);
      letter-spacing: 2px; text-transform: uppercase; z-index: 15;
    }

    /* Reveal Screen */
    #reveal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(3,3,8,0.97);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100; opacity: 0; pointer-events: none;
      transition: opacity 2.5s ease; padding: 40px;
    }
    #reveal.visible { opacity: 1; pointer-events: auto; }
    #reveal h2 {
      font-size: clamp(1.6rem, 4.5vw, 2.8rem); color: rgba(255,255,255,0.9);
      font-weight: 300; margin-bottom: 40px; letter-spacing: 0.12em; text-align: center;
      opacity: 0; animation: revealText 1.5s ease 0.5s forwards;
    }
    #reveal .reveal-text {
      font-size: clamp(1rem, 2.5vw, 1.35rem); color: rgba(255,255,255,0.6);
      max-width: 600px; text-align: center; line-height: 2; margin-bottom: 15px; opacity: 0;
    }
    #reveal .reveal-text:nth-child(2) { animation: revealText 1.5s ease 1.5s forwards; }
    #reveal .reveal-text:nth-child(3) { animation: revealText 1.5s ease 2.5s forwards; }
    #reveal .reveal-text:nth-child(4) { animation: revealText 1.5s ease 3.5s forwards; }
    #reveal .reveal-text:nth-child(5) { animation: revealText 1.5s ease 4.5s forwards; }
    @keyframes revealText { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    #reveal .words-used {
      font-style: italic; color: rgba(255,255,255,0.35); margin-top: 40px;
      font-size: 0.9rem; letter-spacing: 0.1em; opacity: 0;
      animation: revealText 1.5s ease 5.5s forwards;
    }
    #reveal button {
      margin-top: 50px; padding: 16px 50px;
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-size: 1.1rem; font-weight: 400; background: transparent;
      border: 1px solid rgba(255,255,255,0.25); color: rgba(255,255,255,0.7);
      cursor: pointer; letter-spacing: 0.25em; text-transform: uppercase;
      transition: all 0.4s ease; opacity: 0; animation: revealText 1.5s ease 6s forwards;
    }
    #reveal button:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.4); }

    /* Attribution */
    .attribution {
      position: fixed; bottom: 18px; right: 25px;
      font-size: 0.7rem; color: rgba(255,255,255,0.15);
      letter-spacing: 0.12em; z-index: 5;
    }
    .attribution a { color: rgba(255,255,255,0.25); text-decoration: none; }

    @media (max-width: 600px) {
      #stats, #palette-indicator, #mode-indicator { display: none; }
    }
  </style>
</head>
<body>
  <div id="intro">
    <h1>The Question Field</h1>
    <p>An exploration of observation and creation</p>
    <div class="enter-hint">click to enter</div>
  </div>

  <canvas id="canvas"></canvas>
  
  <div id="interface">
    <div id="question">What do you see?</div>
    <div id="input-container">
      <input type="text" id="user-input" placeholder="describe what appears..." autocomplete="off" spellcheck="false">
    </div>
  </div>

  <div id="palette-indicator"></div>
  <div id="mode-indicator">flow</div>
  <div id="stats">
    <div id="particle-count">0 particles</div>
    <div id="fps-display">60 fps</div>
  </div>
  <div id="word-echo"></div>

  <div id="reveal">
    <h2>The observer is the observed</h2>
    <p class="reveal-text">You believed you were describing what you saw.</p>
    <p class="reveal-text">But there was nothing here until you named it.</p>
    <p class="reveal-text">Your words didn't reflect reality — they created it.</p>
    <p class="reveal-text">The one who looks and what is seen are not two things.</p>
    <p class="words-used">Your words: <span id="all-words"></span></p>
    <button onclick="restart()">Begin again</button>
  </div>

  <div class="attribution">
    "Truth is a pathless land" — <a href="https://jkrishnamurti.org" target="_blank" rel="noopener">J. Krishnamurti</a>
  </div>

  <script>
    // ============================================
    // THE QUESTION FIELD - Flow Field Edition
    // ============================================

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const intro = document.getElementById('intro');
    const interfaceEl = document.getElementById('interface');
    const input = document.getElementById('user-input');
    const question = document.getElementById('question');
    const wordEcho = document.getElementById('word-echo');
    const reveal = document.getElementById('reveal');
    const allWordsSpan = document.getElementById('all-words');
    const paletteIndicator = document.getElementById('palette-indicator');
    const modeIndicator = document.getElementById('mode-indicator');

    let width, height;
    let particles = [];
    let flowField = [];
    let cols, rows;
    const scale = 20;
    let zoff = 0;
    let mouseX = 0, mouseY = 0;
    let mouseInfluence = 0;
    let started = false;
    let allWords = [];
    let lastInputTime = 0;
    let revealTriggered = false;
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 60;

    // Visual state
    let state = {
      paletteIndex: 0,
      modeIndex: 0,
      particleCount: 800,
      trailAlpha: 0.05,
      particleSpeed: 1,
      flowStrength: 0.5,
      turbulence: 0.1,
      mouseStrength: 1,
      backgroundColor: [10, 10, 15],
      glowIntensity: 0,
      symmetry: 1,
      waveAmplitude: 0
    };

    const palettes = [
      // Ethereal Purple (default)
      ['#667eea', '#764ba2', '#f953c6', '#b91d73', '#00d2ff'],
      // Ocean Depths
      ['#00c9ff', '#92fe9d', '#00b09b', '#96c93d', '#0575e6'],
      // Sunset Fire
      ['#f12711', '#f5af19', '#fc4a1a', '#f7b733', '#ff416c'],
      // Cyber Neon
      ['#00ff87', '#60efff', '#ff00e5', '#00ffff', '#ff6b6b'],
      // Aurora
      ['#43cea2', '#185a9d', '#6dd5ed', '#2193b0', '#00d2d3'],
      // Cosmic
      ['#fc466b', '#3f5efb', '#a770ef', '#cf8bf3', '#fdb99b'],
      // Monochrome
      ['#ffffff', '#cccccc', '#999999', '#666666', '#ffffff'],
      // Golden
      ['#f7971e', '#ffd200', '#f9a602', '#ff6f00', '#ffeb3b'],
      // Forest
      ['#134e5e', '#71b280', '#2d5016', '#a8e063', '#56ab2f'],
      // Blood Moon
      ['#8e0000', '#ff0000', '#4a0000', '#ff4444', '#220000']
    ];

    const modes = ['flow', 'attract', 'repel', 'vortex', 'orbit', 'explode'];

    // Keywords and effects
    const keywords = {
      // Palettes
      'purple': () => { state.paletteIndex = 0; updatePalette(); },
      'violet': () => { state.paletteIndex = 0; updatePalette(); },
      'ocean': () => { state.paletteIndex = 1; updatePalette(); },
      'water': () => { state.paletteIndex = 1; updatePalette(); state.waveAmplitude = 0.3; },
      'fire': () => { state.paletteIndex = 2; updatePalette(); state.turbulence = 0.3; },
      'flame': () => { state.paletteIndex = 2; updatePalette(); state.turbulence = 0.4; },
      'neon': () => { state.paletteIndex = 3; updatePalette(); state.glowIntensity = 0.5; },
      'cyber': () => { state.paletteIndex = 3; updatePalette(); state.glowIntensity = 0.6; },
      'aurora': () => { state.paletteIndex = 4; updatePalette(); state.waveAmplitude = 0.2; },
      'cosmic': () => { state.paletteIndex = 5; updatePalette(); state.particleCount = 1500; },
      'cosmos': () => { state.paletteIndex = 5; updatePalette(); state.particleCount = 2000; },
      'universe': () => { state.paletteIndex = 5; updatePalette(); state.particleCount = 2500; },
      'white': () => { state.paletteIndex = 6; updatePalette(); },
      'monochrome': () => { state.paletteIndex = 6; updatePalette(); },
      'gold': () => { state.paletteIndex = 7; updatePalette(); state.glowIntensity = 0.3; },
      'golden': () => { state.paletteIndex = 7; updatePalette(); state.glowIntensity = 0.4; },
      'forest': () => { state.paletteIndex = 8; updatePalette(); },
      'nature': () => { state.paletteIndex = 8; updatePalette(); },
      'blood': () => { state.paletteIndex = 9; updatePalette(); },
      'red': () => { state.paletteIndex = 9; updatePalette(); },

      // Modes
      'flow': () => { state.modeIndex = 0; updateMode(); },
      'attract': () => { state.modeIndex = 1; updateMode(); state.mouseStrength = 2; },
      'pull': () => { state.modeIndex = 1; updateMode(); },
      'repel': () => { state.modeIndex = 2; updateMode(); state.mouseStrength = 2; },
      'push': () => { state.modeIndex = 2; updateMode(); },
      'vortex': () => { state.modeIndex = 3; updateMode(); },
      'spiral': () => { state.modeIndex = 3; updateMode(); state.flowStrength = 0.8; },
      'orbit': () => { state.modeIndex = 4; updateMode(); },
      'circle': () => { state.modeIndex = 4; updateMode(); },
      'explode': () => { state.modeIndex = 5; updateMode(); state.particleSpeed = 2; },
      'burst': () => { state.modeIndex = 5; updateMode(); },

      // Particle count
      'more': () => { state.particleCount = Math.min(state.particleCount + 500, 5000); },
      'many': () => { state.particleCount = 2000; },
      'infinite': () => { state.particleCount = 4000; },
      'few': () => { state.particleCount = 200; },
      'less': () => { state.particleCount = Math.max(state.particleCount - 500, 100); },
      'empty': () => { state.particleCount = 50; state.trailAlpha = 0.02; },
      'void': () => { state.particleCount = 10; state.backgroundColor = [0,0,0]; },
      'nothing': () => { state.particleCount = 0; },

      // Speed
      'fast': () => { state.particleSpeed = 3; state.flowStrength = 1; },
      'slow': () => { state.particleSpeed = 0.3; state.flowStrength = 0.2; },
      'frozen': () => { state.particleSpeed = 0; },
      'still': () => { state.particleSpeed = 0.1; state.flowStrength = 0.1; },
      'calm': () => { state.particleSpeed = 0.4; state.turbulence = 0; },
      'peace': () => { state.particleSpeed = 0.3; state.turbulence = 0; state.trailAlpha = 0.03; },
      'chaos': () => { state.turbulence = 0.5; state.particleSpeed = 2; },
      'storm': () => { state.turbulence = 0.6; state.particleSpeed = 2.5; },
      'gentle': () => { state.particleSpeed = 0.5; state.flowStrength = 0.3; },

      // Trails
      'trails': () => { state.trailAlpha = 0.02; },
      'streaks': () => { state.trailAlpha = 0.01; },
      'fade': () => { state.trailAlpha = 0.15; },
      'clear': () => { state.trailAlpha = 0.3; },
      'ghost': () => { state.trailAlpha = 0.008; },

      // Visual effects
      'glow': () => { state.glowIntensity = 0.6; },
      'bright': () => { state.glowIntensity = 0.8; state.backgroundColor = [15,15,20]; },
      'dark': () => { state.backgroundColor = [2,2,5]; state.glowIntensity = 0; },
      'darkness': () => { state.backgroundColor = [0,0,0]; },
      'light': () => { state.backgroundColor = [20,20,30]; state.glowIntensity = 0.5; },

      // Patterns
      'symmetry': () => { state.symmetry = 2; },
      'mirror': () => { state.symmetry = 2; },
      'kaleidoscope': () => { state.symmetry = 6; },
      'mandala': () => { state.symmetry = 8; state.modeIndex = 4; updateMode(); },
      'radial': () => { state.symmetry = 4; },

      // Concepts
      'consciousness': () => { state.particleCount = 2000; state.glowIntensity = 0.4; state.paletteIndex = 5; updatePalette(); },
      'awareness': () => { state.glowIntensity = 0.5; state.trailAlpha = 0.03; },
      'thought': () => { state.modeIndex = 3; updateMode(); state.turbulence = 0.2; },
      'mind': () => { state.particleCount = 1500; state.modeIndex = 3; updateMode(); },
      'dream': () => { state.trailAlpha = 0.015; state.particleSpeed = 0.6; state.paletteIndex = 0; updatePalette(); },
      'love': () => { state.paletteIndex = 2; updatePalette(); state.modeIndex = 1; updateMode(); state.glowIntensity = 0.5; },
      'energy': () => { state.particleSpeed = 2; state.paletteIndex = 3; updatePalette(); },
      'life': () => { state.paletteIndex = 8; updatePalette(); state.particleCount = 1500; },
      'death': () => { state.paletteIndex = 6; updatePalette(); state.particleSpeed = 0.2; state.trailAlpha = 0.01; },
      'birth': () => { state.modeIndex = 5; updateMode(); state.glowIntensity = 0.7; },
      'stars': () => { state.particleCount = 2000; state.trailAlpha = 0.02; state.backgroundColor = [2,2,8]; },
      'galaxy': () => { state.modeIndex = 3; updateMode(); state.particleCount = 2500; state.paletteIndex = 5; updatePalette(); },
      'nebula': () => { state.trailAlpha = 0.01; state.glowIntensity = 0.4; state.paletteIndex = 5; updatePalette(); },
      'breath': () => { state.waveAmplitude = 0.3; state.particleSpeed = 0.5; },
      'heartbeat': () => { state.waveAmplitude = 0.5; },
      'pulse': () => { state.waveAmplitude = 0.4; },
      'wave': () => { state.waveAmplitude = 0.3; state.paletteIndex = 1; updatePalette(); },
      'dance': () => { state.turbulence = 0.3; state.particleSpeed = 1.5; },
      'music': () => { state.turbulence = 0.25; state.waveAmplitude = 0.2; },
      'silence': () => { state.particleSpeed = 0.2; state.turbulence = 0; state.trailAlpha = 0.02; },
      'truth': () => { state.paletteIndex = 6; updatePalette(); state.glowIntensity = 0.6; },
      'beauty': () => { state.paletteIndex = 4; updatePalette(); state.glowIntensity = 0.4; },
      'infinity': () => { state.modeIndex = 4; updateMode(); state.particleCount = 3000; },
      'eternity': () => { state.trailAlpha = 0.005; state.particleCount = 2000; }
    };

    // Noise function
    function noise(x, y, z) {
      const n = Math.sin(x * 0.5 + z) * Math.cos(y * 0.5 + z) +
                Math.sin(x * 0.3 - z * 0.5) * Math.cos(y * 0.3) +
                Math.sin(x * 0.7 + y * 0.7 + z * 2) * 0.5;
      return (n + 2) / 4;
    }

    class Particle {
      constructor() { this.reset(); }
      
      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = 0;
        this.vy = 0;
        this.life = Math.random() * 200 + 100;
        this.maxLife = this.life;
        this.colorIndex = Math.floor(Math.random() * palettes[state.paletteIndex].length);
      }
      
      update() {
        const col = Math.floor(this.x / scale);
        const row = Math.floor(this.y / scale);
        const index = col + row * cols;
        
        if (flowField[index] !== undefined) {
          const force = flowField[index];
          this.vx += Math.cos(force) * state.flowStrength;
          this.vy += Math.sin(force) * state.flowStrength;
        }

        // Turbulence
        if (state.turbulence > 0) {
          this.vx += (Math.random() - 0.5) * state.turbulence;
          this.vy += (Math.random() - 0.5) * state.turbulence;
        }
        
        // Mouse influence
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const influence = Math.min(200 / (dist + 1), 4) * mouseInfluence * state.mouseStrength;
        
        switch(modes[state.modeIndex]) {
          case 'attract':
            this.vx += (dx / dist) * influence * 0.3;
            this.vy += (dy / dist) * influence * 0.3;
            break;
          case 'repel':
            this.vx -= (dx / dist) * influence * 0.5;
            this.vy -= (dy / dist) * influence * 0.5;
            break;
          case 'vortex':
            this.vx += (-dy / dist) * influence * 0.3;
            this.vy += (dx / dist) * influence * 0.3;
            break;
          case 'orbit':
            const angle = Math.atan2(dy, dx);
            this.vx += Math.cos(angle + Math.PI/2) * influence * 0.2;
            this.vy += Math.sin(angle + Math.PI/2) * influence * 0.2;
            break;
          case 'explode':
            if (dist < 200) {
              this.vx -= (dx / dist) * influence * 0.8;
              this.vy -= (dy / dist) * influence * 0.8;
            }
            break;
          default:
            this.vx += (dx / dist) * influence * 0.1;
            this.vy += (dy / dist) * influence * 0.1;
        }
        
        this.x += this.vx * state.particleSpeed;
        this.y += this.vy * state.particleSpeed;
        this.vx *= 0.98;
        this.vy *= 0.98;
        
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > 5) {
          this.vx = (this.vx / speed) * 5;
          this.vy = (this.vy / speed) * 5;
        }
        
        this.life--;
        
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
        
        if (this.life <= 0) this.reset();
      }
      
      draw() {
        const alpha = Math.min(this.life / 50, 1) * Math.min((this.maxLife - this.life) / 20, 1);
        const color = palettes[state.paletteIndex][this.colorIndex % palettes[state.paletteIndex].length];
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha * 0.8;
        ctx.fill();
        
        // Trail
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 4, this.y - this.vy * 4);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = alpha * 0.4;
        ctx.stroke();

        // Glow effect
        if (state.glowIntensity > 0) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.globalAlpha = alpha * state.glowIntensity * 0.2;
          ctx.fill();
        }
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      cols = Math.floor(width / scale) + 1;
      rows = Math.floor(height / scale) + 1;
      flowField = new Array(cols * rows);
    }

    function updatePalette() {
      paletteIndicator.innerHTML = palettes[state.paletteIndex]
        .map(c => `<div class="color-dot" style="background:${c}"></div>`)
        .join('');
    }

    function updateMode() {
      modeIndicator.textContent = modes[state.modeIndex];
    }

    function initParticles() {
      const targetCount = Math.min(state.particleCount, 5000);
      while (particles.length < targetCount) particles.push(new Particle());
      while (particles.length > targetCount) particles.pop();
    }

    function updateFlowField() {
      const waveOffset = state.waveAmplitude > 0 ? Math.sin(zoff * 2) * state.waveAmplitude : 0;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const index = x + y * cols;
          const angle = noise(x * 0.1, y * 0.1, zoff) * Math.PI * 4 + waveOffset;
          flowField[index] = angle;
        }
      }
      zoff += 0.003;
    }

    function init() {
      resize();
      initParticles();
      updatePalette();
      updateMode();
    }

    function startExperience() {
      if (started) return;
      started = true;
      intro.classList.add('hidden');
      
      // Random starting keyword
      const startingKeywords = ['cosmos', 'spiral', 'aurora', 'dream', 'flow', 'nebula', 'gentle'];
      const randomKeyword = startingKeywords[Math.floor(Math.random() * startingKeywords.length)];
      if (keywords[randomKeyword]) keywords[randomKeyword]();
      initParticles();
      
      setTimeout(() => {
        interfaceEl.classList.add('visible');
        input.focus();
      }, 500);
    }

    function handleInput(e) {
      const text = e.target.value.toLowerCase();
      const words = text.split(/\s+/);
      
      for (const word of words) {
        const cleanWord = word.replace(/[^a-z]/g, '');
        if (keywords[cleanWord] && !allWords.includes(cleanWord)) {
          keywords[cleanWord]();
          allWords.push(cleanWord);
          showWordEcho(cleanWord);
          initParticles();
        }
      }
      
      question.classList.toggle('faded', text.length > 0);
      lastInputTime = Date.now();
      
      if (allWords.length >= 5 && !revealTriggered) {
        setTimeout(checkForReveal, 12000);
      }
    }

    function showWordEcho(word) {
      wordEcho.textContent = word;
      wordEcho.classList.add('visible');
      setTimeout(() => wordEcho.classList.remove('visible'), 2500);
    }

    function checkForReveal() {
      if (Date.now() - lastInputTime > 10000 && allWords.length >= 5 && !revealTriggered) {
        triggerReveal();
      }
    }

    function triggerReveal() {
      revealTriggered = true;
      allWordsSpan.textContent = allWords.join(' · ');
      setTimeout(() => reveal.classList.add('visible'), 1500);
    }

    function restart() {
      reveal.classList.remove('visible');
      revealTriggered = false;
      allWords = [];
      input.value = '';
      question.classList.remove('faded');
      
      state = {
        paletteIndex: 0, modeIndex: 0, particleCount: 800,
        trailAlpha: 0.05, particleSpeed: 1, flowStrength: 0.5,
        turbulence: 0.1, mouseStrength: 1, backgroundColor: [10, 10, 15],
        glowIntensity: 0, symmetry: 1, waveAmplitude: 0
      };
      
      particles = [];
      init();
      input.focus();
    }

    function animate() {
      // Background with trail effect
      const [r, g, b] = state.backgroundColor;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${state.trailAlpha})`;
      ctx.fillRect(0, 0, width, height);
      ctx.globalAlpha = 1;
      
      updateFlowField();
      
      // Update particles
      initParticles();
      for (const p of particles) {
        p.update();
        p.draw();
      }
      
      // FPS
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
      }
      
      document.getElementById('particle-count').textContent = `${particles.length} particles`;
      document.getElementById('fps-display').textContent = `${fps} fps`;
      
      mouseInfluence *= 0.95;
      requestAnimationFrame(animate);
    }

    // Event listeners
    window.addEventListener('resize', resize);
    intro.addEventListener('click', startExperience);
    intro.addEventListener('touchstart', startExperience);
    input.addEventListener('input', handleInput);
    
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      mouseInfluence = 1;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      mouseX = e.touches[0].clientX;
      mouseY = e.touches[0].clientY;
      mouseInfluence = 1;
    }, { passive: false });

    // Start
    init();
    animate();
  </script>
</body>
</html>
